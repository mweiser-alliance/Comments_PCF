"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildContext = void 0;
exports.findControlFolders = findControlFolders;
const fs = require("node:fs");
const path = require("node:path");
const constants = require("./constants");
const controlContext_1 = require("./controlContext");
const designContext_1 = require("./designContext");
const diagnosticMessages_generated_1 = require("./diagnosticMessages.generated");
const featureManager_1 = require("./featureManager");
// Searches the provided directory for control folders.
// A control folder is defined as containing a ControlManifest.Input.xml file.
function findControlFolders(cwd, excludedFolders) {
    let results = [];
    if (fs.existsSync(path.join(cwd, constants.MANIFEST_INPUT_FILE_NAME))) {
        results.push(cwd);
        return results;
    }
    const folders = fs.readdirSync(cwd).filter((file) => fs.statSync(path.join(cwd, file)).isDirectory());
    folders.forEach((folder) => {
        const currentFolder = path.join(cwd, folder);
        if (excludedFolders?.find((elem) => elem === currentFolder)) {
            return;
        }
        else {
            results = results.concat(findControlFolders(currentFolder));
        }
    });
    return results;
}
// Context for building PCF controls
class BuildContext {
    constructor(diag, config) {
        this.config = config;
        this._diag = diag;
        this._featureManager = new featureManager_1.FeatureManager();
        if (config.controlsRoot) {
            this.controls = this.getControls();
        }
        if (this._featureManager.isFeatureEnabled("pcfTheming")) {
            this.designMapContext = this.getDesignContexts();
        }
    }
    // Gets the controls root directory
    getControlsRoot() {
        return this.config.controlsRoot;
    }
    // Gets the output directory
    getOutDir() {
        return this.config.outDir;
    }
    // Gets the build mode
    getBuildMode() {
        return this.config.buildMode;
    }
    // Gets the locale
    getLocale() {
        return this.config.locale;
    }
    getSkipBuildLinting() {
        return this.config.skipBuildLinting;
    }
    // Gets the diagnostic manager
    getDiagnostic() {
        return this._diag;
    }
    getDesignContexts() {
        return this.controls?.filter((control) => this.isThemedControl(control))?.map((control) => new designContext_1.DesignContext(this._diag, control));
    }
    // Maps the specified callback for each control under the root directory
    mapControls(callback) {
        if (!this.config.controlsRoot) {
            this._diag.pushA(diagnosticMessages_generated_1.strings.buildconfig_not_defined, ["controlsRoot"]);
            return Promise.reject(new Error());
        }
        if (!this.controls || this.controls.length === 0) {
            this._diag.pushA(diagnosticMessages_generated_1.strings.control_manifest_not_found, [constants.MANIFEST_INPUT_FILE_NAME]);
            return Promise.reject(new Error());
        }
        const results = this.controls.map((value) => callback(value));
        return Promise.all(results);
    }
    // maps the specified callback for each design map under the control root
    mapDesignFile(callback) {
        if (this.needsToProcessAsStandardControl()) {
            this._diag.push(diagnosticMessages_generated_1.strings.processing_as_standard_control);
            return Promise.resolve();
        }
        const results = this.designMapContext?.map((value) => callback(value));
        return results ? Promise.all(results) : Promise.resolve();
    }
    // Gets the list of controls under the controls root directory
    getControls() {
        if (!this.config.controlsRoot) {
            return [];
        }
        // Exclude node_modules and outdir from control folder search
        const exludedFolders = [path.join(this.config.controlsRoot, "node_modules")];
        if (this.config.outDir) {
            exludedFolders.push(path.join(this.config.controlsRoot, this.config.outDir));
        }
        const controls = findControlFolders(this.config.controlsRoot, exludedFolders);
        return controls.map((controlPath) => {
            return new controlContext_1.ControlContext(this._diag, controlPath);
        });
    }
    needsToProcessAsStandardControl() {
        if (this._featureManager.isFeatureEnabled("pcfTheming")) {
            return this.controls?.every((control) => !this.isThemedControl(control)) ?? true;
        }
        return true;
    }
    isThemedControl(control) {
        return control.getControlManifest().data.manifest.control.$["design-mapping-file"] !== undefined;
    }
    shouldUseESBuild() {
        return this._featureManager.isFeatureEnabled("pcfUseESBuild");
    }
}
exports.BuildContext = BuildContext;

//# sourceMappingURL=buildContext.js.map
