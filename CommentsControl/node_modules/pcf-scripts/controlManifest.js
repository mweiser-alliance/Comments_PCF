"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlManifest = void 0;
const lodash_1 = require("lodash");
const xml2js_1 = require("xml2js");
const constants = require("./constants");
class ControlManifest {
    constructor(manifestObj) {
        this.data = manifestObj;
    }
    getControlVersion() {
        return this.data.manifest.control.$.version;
    }
    setControlVersion(newVersion) {
        this.data.manifest.control.$.version = newVersion;
    }
    getManifestData() {
        return this.data;
    }
    getNamespace() {
        return this.data.manifest.control.$.namespace;
    }
    getConstructor() {
        return this.data.manifest.control.$.constructor;
    }
    getCodePath() {
        return this.data.manifest.control.resources[constants.CODE_ELEM_NAME][0].$.path;
    }
    getPreviewImagePath() {
        return this.data.manifest.control.$["preview-image"];
    }
    getDesignMapsFilePath() {
        return this.data.manifest.control.$["design-mapping-file"];
    }
    // Return an array of paths of the control's resources relative to that control's root folder
    // includeTs flag determines whether <code> element's path will be included
    getResources(includeTs) {
        const resources = this.data.manifest.control.resources;
        const pathsCollection = [];
        Object.entries(resources)
            .filter(([resourceType]) => resourceType !== constants.PLATFORM_LIBRARY_ELEM_NAME && resourceType !== constants.RES_DEPENDENCY_ELEM_NAME)
            .forEach(([resourceType, resourceValue]) => {
            let paths;
            if (resourceType !== constants.LIBRARY_ELEM_NAME) {
                paths = resourceType === constants.CODE_ELEM_NAME && !includeTs ? [] : resourceValue.map((resource) => resource.$.path);
            }
            else {
                paths = (0, lodash_1.flatMap)(resourceValue, (resource) => resource.packaged_library?.map((packagedLib) => packagedLib.$.path) ?? []);
            }
            pathsCollection.push(...paths);
        });
        return pathsCollection;
    }
    // Build xml string from the ControlManifest's json object
    getManifestXmlString() {
        const clonedData = this.removeOutputDirectoryAttr();
        const jsonToXmlbuilder = new xml2js_1.Builder();
        const xml = jsonToXmlbuilder.buildObject(clonedData);
        return xml;
    }
    removeOutputDirectoryAttr() {
        const clonedData = (0, lodash_1.cloneDeep)(this.data);
        const clonedResources = (0, lodash_1.cloneDeep)(this.data.manifest.control.resources);
        Object.entries(clonedResources).forEach(([resourceType, resourceValue]) => {
            resourceValue.forEach((resource) => {
                if (resourceType === constants.LIBRARY_ELEM_NAME) {
                    resource.packaged_library?.forEach((packagedLib) => {
                        if (packagedLib.$.outputDirectory) {
                            delete packagedLib.$.outputDirectory;
                        }
                    });
                }
                else if (resource.$?.outputDirectory) {
                    delete resource.$.outputDirectory;
                }
            });
        });
        clonedData.manifest.control.resources = clonedResources;
        return clonedData;
    }
}
exports.ControlManifest = ControlManifest;

//# sourceMappingURL=controlManifest.js.map
