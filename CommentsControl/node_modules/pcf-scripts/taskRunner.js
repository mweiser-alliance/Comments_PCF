"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskRunner = void 0;
const path = require("path");
const buildContext_1 = require("./buildContext");
const constants = require("./constants");
const diagnostic_1 = require("./diagnostic");
const diagnosticMessages_generated_1 = require("./diagnosticMessages.generated");
const locale_1 = require("./generated/locale");
class TaskRunner {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(args, config) {
        this._colorize = true;
        if (args?.noColor) {
            this._colorize = false;
        }
        this._diagnostics = new diagnostic_1.DiagnosticManager();
        this._args = args;
        this._config = config;
    }
    async run(taskGroup) {
        // Set locale
        try {
            await this.setLocale();
        }
        catch (err) {
            console.log(`Error setting locale: ${err}`);
            return;
        }
        // Validate configuration
        this.validateConfiguration();
        if (!this.checkDiagnostics()) {
            return;
        }
        // Set commandName and subCommandName after validate configuration
        this.setCommandNames();
        const tg = this.getTaskGroup(taskGroup);
        if (!this.checkDiagnostics()) {
            return;
        }
        const tsg = this.getTaskSubGroup(tg);
        if (!this.checkDiagnostics()) {
            return;
        }
        // Create build context
        this.logMessage(`${(0, locale_1.translate)(diagnosticMessages_generated_1.strings.initializing.key)}...`);
        this.initializeBuildContext();
        if (!this.checkDiagnostics()) {
            return;
        }
        let taskResult = {};
        // Run tasks
        for (const task of Object.values(tsg)) {
            this.logMessage(`${task.getDescription()}...`);
            try {
                task.setOptions({ colorize: this._colorize });
                if (this._args?.pcfStartPath) {
                    task.setOptions({ pcfStartPath: this._args.pcfStartPath });
                }
                const result = await task.run(this._buildContext);
                if (Array.isArray(result) && result[0] && !Array.isArray(result[0])) {
                    taskResult = { ...result[0] };
                }
            }
            catch (err) {
                // Only throw error text is no errors were logged to diagnostics
                if (err && !this._diagnostics.hasErrors()) {
                    throw err;
                }
                this.logError(`${(0, locale_1.translate)(diagnosticMessages_generated_1.strings.failed.key)}:`);
                this._diagnostics.flush(this._colorize);
                return;
            }
        }
        this.logMessage(`${(0, locale_1.translate)(diagnosticMessages_generated_1.strings.succeeded.key)}`);
        this._diagnostics.flush(this._colorize);
        return taskResult;
    }
    setCommandNames() {
        // This is validated in validateConfiguration
        this._commandName = this._args._[0];
        if (this._args._.length > 1) {
            this._subCommandName = this._args._[1];
        }
        else {
            this._subCommandName = "default";
        }
    }
    getDiagnostics() {
        return this._diagnostics;
    }
    checkDiagnostics() {
        if (this._diagnostics.hasErrors()) {
            this._diagnostics.flush(this._colorize);
            return false;
        }
        return true;
    }
    // Sets the locale for the task runner
    async setLocale() {
        const locale = this._args?.locale ?? this._config?.locale ?? constants.DEFAULT_LANGUAGE;
        try {
            await (0, locale_1.configureLocale)({
                directory: path.resolve(__dirname, "loc"),
                diagnosticFileName: "diagnosticMessages.localized.json",
                locale,
                runtime: "node",
            });
        }
        catch (err) {
            this._diagnostics.push({
                code: 0,
                category: "Error",
                key: undefined,
                message: `Error setting locale ${err}`,
            });
        }
    }
    // Validates configuration parameters
    validateConfiguration() {
        if (!this._args?._?.length) {
            this._diagnostics.push(diagnosticMessages_generated_1.strings.pcf_scripts_not_valid_command);
        }
        if (this._args.buildMode) {
            this.validateBuildMode(this._args.buildMode);
        }
        if (this._config?.buildMode) {
            this.validateBuildMode(this._config.buildMode);
        }
        if (this._config?.controlsRoot && this._args?.controlsRoot) {
            this.validateConfigPaths(this._config.controlsRoot, this._args.controlsRoot, "controlsRoot");
        }
        if (this._config?.outDir && this._args?.outDir) {
            this.validateConfigPaths(this._config.outDir, this._args.outDir, "outDir");
        }
    }
    initializeBuildContext() {
        const config = {
            controlsRoot: ".",
            outDir: this._args?.outDir ?? this._config?.outDir ?? constants.DEFAULT_OUT_DIR,
            buildMode: this._args?.buildMode ?? this._config?.buildMode ?? constants.DEFAULT_BUILD_MODE,
            locale: this._args?.locale ?? this._config?.locale ?? constants.DEFAULT_LANGUAGE,
            skipBuildLinting: (this._args?.skipBuildLinting ?? this._config?.skipBuildLinting)?.toString().toLowerCase() === "true",
        };
        if (config.buildMode === "none") {
            config.buildMode = "development";
        }
        this._buildContext = new buildContext_1.BuildContext(this._diagnostics, config);
    }
    getTaskGroup(taskGroups) {
        const tg = taskGroups[this._commandName];
        if (!tg) {
            this._diagnostics.push(diagnosticMessages_generated_1.strings.pcf_scripts_not_valid_command);
        }
        return tg;
    }
    getTaskSubGroup(taskGroup) {
        const tsg = taskGroup[this._subCommandName];
        if (!tsg) {
            this._diagnostics.pushA(diagnosticMessages_generated_1.strings.pcf_scripts_not_valid_subcommand, [this._subCommandName]);
        }
        return tsg;
    }
    validateBuildMode(mode) {
        if (mode !== "development" && mode !== "production" && mode !== "none") {
            this._diagnostics.pushA(diagnosticMessages_generated_1.strings.buildconfig_unsupported_build_mode, [mode]);
        }
    }
    validateConfigPaths(path1, path2, configName) {
        if (!this.arePathsEqual(path1, path2)) {
            this._diagnostics.pushA(diagnosticMessages_generated_1.strings.buildconfig_mismatched_configuration, [configName, constants.CONFIGURATION_FILE_NAME]);
        }
    }
    // Checks if two paths resolve to the same locale
    arePathsEqual(path1, path2) {
        if (path1 && path2) {
            const resolvedPath1 = path.resolve(path1);
            const resolvedPath2 = path.resolve(path2);
            const root1 = path.parse(resolvedPath1).root;
            const root2 = path.parse(resolvedPath2).root;
            // This check will need to be updated when running on file systems that care about case.
            return (root1.toLowerCase() === root2.toLowerCase() &&
                path.relative(root2, resolvedPath1).toLowerCase() === path.relative(root2, resolvedPath2).toLowerCase());
        }
        return path1 === path2;
    }
    logMessage(message) {
        console.log(`[${this.getCurrentTime()}] [${this._commandName}]${this.getSubCommandLogName()} ${message}`);
    }
    logError(message) {
        if (this._colorize) {
            console.log(constants.COLOR_RED_RESET, `[${this.getCurrentTime()}] [${this._commandName}]${this.getSubCommandLogName()} ${message}`);
        }
        else {
            console.log(`[${this.getCurrentTime()}] [${this._commandName}]${this.getSubCommandLogName()} ${message}`);
        }
    }
    getSubCommandLogName() {
        return this._subCommandName === "default" ? "" : ` [${this._subCommandName}]`;
    }
    getCurrentTime() {
        const dt = new Date();
        return dt.toLocaleTimeString();
    }
}
exports.TaskRunner = TaskRunner;

//# sourceMappingURL=taskRunner.js.map
